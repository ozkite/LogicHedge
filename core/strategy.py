"""
Base strategy class for all trading strategies.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
import logging
from dataclasses import dataclass

from .event_bus import Event, EventBus

logger = logging.getLogger(__name__)

@dataclass
class TradeSignal:
    """Trading signal generated by strategy"""
    symbol: str
    side: str  # "BUY" or "SELL"
    quantity: float
    order_type: str = "MARKET"
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class BaseStrategy(ABC):
    """Abstract base class for all trading strategies"""
    
    def __init__(self, name: str, event_bus: EventBus, config: Dict[str, Any]):
        self.name = name
        self.event_bus = event_bus
        self.config = config
        self.running = False
        self.positions = {}
        self.logger = logging.getLogger(f"{__name__}.{name}")
        
        # Subscribe to market data events
        self.event_bus.subscribe("market_data", self.on_market_data)
        self.event_bus.subscribe("order_filled", self.on_order_filled)
        self.event_bus.subscribe("position_update", self.on_position_update)
        
    @abstractmethod
    async def calculate_signals(self, market_data: Dict[str, Any]) -> List[TradeSignal]:
        """Calculate trading signals based on market data"""
        pass
    
    async def on_market_data(self, event: Event):
        """Handle incoming market data"""
        if not self.running:
            return
            
        try:
            signals = await self.calculate_signals(event.data)
            for signal in signals:
                await self._execute_signal(signal)
        except Exception as e:
            self.logger.error(f"Error processing market data: {e}")
            
    async def on_order_filled(self, event: Event):
        """Handle order filled events"""
        order_data = event.data
        self.logger.info(f"Order filled: {order_data}")
        # Update strategy state based on filled order
        
    async def on_position_update(self, event: Event):
        """Handle position update events"""
        position_data = event.data
        self.positions[position_data['symbol']] = position_data
        
    async def _execute_signal(self, signal: TradeSignal):
        """Execute trading signal"""
        execution_event = Event(
            event_type="trade_signal",
            data={
                "strategy": self.name,
                "signal": signal.__dict__,
                "timestamp": signal.metadata.get('timestamp')
            },
            source=self.name
        )
        await self.event_bus.publish(execution_event)
        
    async def start(self):
        """Start strategy"""
        self.running = True
        self.logger.info(f"Strategy '{self.name}' started")
        
    async def stop(self):
        """Stop strategy"""
        self.running = False
        self.logger.info(f"Strategy '{self.name}' stopped")
        
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get strategy performance metrics"""
        return {
            "name": self.name,
            "running": self.running,
            "positions": len(self.positions),
            "config": self.config
        }
